#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int check_authentication(char *password) {
    int auth_flag = 0;
    char password_buffer[16]; // We assume the password to be at most 16 bytes (chars)

    /*
        NOTE that here we don't check for a password > 16 bytes, 
        which makes the program vulnerable to an overflow hack:
        since auth_flag is later in memory than password_buffer, the excess space of the input
        argument will overflow into auth_flag and raise (overwrite) its number value. 
        We can simply fix this by reverting the order of the auth_flag and password_buffer declarations.

        BUT, we can still cause the program to overflow and overwrite a value. 
        After the check_authentication function is called, the program should return to the point
        in the main function where it left off. The return memory address is put in stack memory
        AFTER the local variables. So with an overflowing command line argument, we can overwrite
        the return address, setting it to a random location in memory, and thus making the program crash
        or go to a very specific location.

        NB All of this doesn't seem to work anymore when I try to cause an overflow, 
        I get the error [1]    50391 illegal hardware instruction 
    */

    strcpy(password_buffer, password);

    // strcmp: string compare
    if (strcmp(password_buffer, "dino") == 0)
        auth_flag = 1;

    if (strcmp(password_buffer, "erle") == 0)
        auth_flag = 1;

    return auth_flag;
}

int main(int argc, char *argv[])
{
    if (argc < 2) {
        printf("Usage: %s <password>\n", argv[0]);
        exit(0);
    }

    if (check_authentication(argv[1])) {
        printf("ACCESS GRANTED\n");
    } else {
        printf("ACCESS DENIED\n");
    }
}
