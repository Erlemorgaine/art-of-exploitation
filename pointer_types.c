#include <stdio.h>

int main()
{
    int i;

    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};

    char *char_pointer;
    int *int_pointer;

    // We set the pointers to the start of the arrays
    char_pointer = char_array;
    int_pointer = int_array;

    for (i = 0; i < 5; i++)
    {
        // %p is to return the memory address, shorthand for 0x%08x
        printf("[integer pointer] points to %p, which contains the integer %d\n", int_pointer, *int_pointer);

        // We increase the position of the pointer to point at next value in array
        // NB Since we have indicated that int_pointer is an int, +1 amounts to +4 bytes
        int_pointer = int_pointer + 1;
    }
    
    for (i = 0; i < 5; i++)
    {
        // %p is to return the memory address, shorthand for 0x%08x
        printf("[char pointer] points to %p, which contains the char %c\n", char_pointer, *char_pointer);

        // We increase the position of the pointer to point at next value in array
        char_pointer = char_pointer + 1;
    }

    // Here we have the same code, but with typecasting in action

    char_pointer = (char *) int_array;
    int_pointer = (int *) char_array;

    for (i = 0; i < 5; i++)
    {
        // %p is to return the memory address, shorthand for 0x%08x
        printf("[integer pointer] points to %p, which contains the char %c\n", int_pointer, *int_pointer);

        // Since int_pointer now contains chars, we have to typecast the increase to use the correct amount of bytes
        // and then typecast back
        int_pointer = (int *) ((char *) int_pointer + 1);
    }
    
    for (i = 0; i < 5; i++)
    {
        // %p is to return the memory address, shorthand for 0x%08x
        printf("[char pointer] points to %p, which contains the integer %d\n", char_pointer, *char_pointer);

        // Since char_pointer now contains integers, we have to typecast the increase to use the correct amount of bytes
        // and then typecast back
        char_pointer = (char *) ((int *) char_pointer + 1);
    }

    // We can also use a void pointer, which is nothing more than a memory address, so it can hold any type of data
    void *void_pointer;

    void_pointer = (void *) char_array;

     for (i = 0; i < 5; i++)
    {
        // %p is to return the memory address, shorthand for 0x%08x
        printf("[void pointer] points to %p, which contains the char %c\n", void_pointer, *((char *) void_pointer));

        // Since int_pointer now contains chars, we have to typecast the increase to use the correct amount of bytes
        // and then typecast back
        void_pointer = (void *) ((char *) void_pointer + 1);
    }

    // BUT we can also do this in a hacky way, using anything as pointer that can hold 4 bytes

    unsigned int hacky_nonpointer;

    hacky_nonpointer = (unsigned int) int_array;

     for (i = 0; i < 5; i++)
    {
    //     // %p is to return the memory address, shorthand for 0x%08x
        printf(
            "[hacky_nonpointer] points to %p, which contains the int %d\n", 
            hacky_nonpointer, 
            // There is a problem with this line but i'm not sure what it is
            *((int *) hacky_nonpointer)
        );

    //     // Note: we use the sizeof to get the correct amount of bytes for the data type
        hacky_nonpointer = hacky_nonpointer + sizeof(int);
    }
}
